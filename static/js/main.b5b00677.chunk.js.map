{"version":3,"sources":["Path_visualizer/Node/Node.jsx","Algorithms/breadthFirstSearch.js","Algorithms/dijkastra.js","Algorithms/dfs.js","Algorithms/astar.js","Path_visualizer/ui.js","Path_visualizer/Path_visualizer.jsx","App.js","reportWebVitals.js","index.js"],"names":["Node","this","props","col","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","row","extraClassName","id","className","Component","breadthFirstSearch","grid","startNode","finishNode","visitedNodesInOrder","queue","length","closestNode","shift","isVisited","push","nextNode","previousNode","dijkstra","distance","unvisitedNodes","nodes","node","getAllNodes","sortNodesByDistance","Infinity","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","dfs","stack","pop","astar","useStyles","makeStyles","theme","root","flexGrow","title","subTitle","ButtonAppBar","classes","AppBar","position","style","background","Toolbar","Typography","variant","Button","padding","backgroundColor","color","fontSize","Path_visualizer","state","mouseIsPressed","getInitialGrid","setState","newGrid","getNewGridWithWallToggled","nodesInShortestPathOrder","i","setTimeout","animateShortestPath","document","getElementById","algo","currentNode","unshift","getNodesInShortestPathOrder","animateAlgo","onClick","visualize","map","rowIdx","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","currentRow","createNode","slice","newNode","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.b5b00677.chunk.js","sourcesContent":["import React, { Component } from 'react';\r\n\r\nimport './Node.css';\r\n\r\nexport default class Node extends Component {\r\n\r\n    render() {\r\n        const { \r\n            col, \r\n            isFinish, \r\n            isStart,\r\n            isWall,\r\n            onMouseDown,\r\n            onMouseEnter,\r\n            onMouseUp,\r\n            row,\r\n    } = this.props;\r\n        const extraClassName = isFinish\r\n            ? 'node-finish'\r\n            : isStart\r\n            ? 'node-start'\r\n            : isWall\r\n            ? 'node-wall'\r\n            : '';\r\n\r\n        return (\r\n            <div \r\n                id={`node-${row}-${col}`}\r\n                className={`node ${extraClassName}`}\r\n                onMouseDown={() => onMouseDown(row, col)}\r\n                onMouseEnter={() => onMouseEnter(row, col)}\r\n                onMouseUp={() => onMouseUp(row, col)}\r\n            ></div>\r\n        );\r\n    }\r\n}\r\n","// main breadthfirstsearch function\r\nexport function breadthFirstSearch(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  const queue = [startNode];\r\n  while (!!queue.length) {\r\n    const closestNode = queue.shift();\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n    if (\r\n      !closestNode.isWall &&\r\n      (closestNode.isStart || !closestNode.isVisited)\r\n    ) {\r\n      closestNode.isVisited = true;\r\n      visitedNodesInOrder.push(closestNode);\r\n      const { col, row } = closestNode;\r\n      let nextNode;\r\n      if (row > 0) {\r\n        nextNode = grid[row - 1][col];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = closestNode;\r\n          queue.push(nextNode);\r\n        }\r\n      }\r\n      if (row < grid.length - 1) {\r\n        nextNode = grid[row + 1][col];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = closestNode;\r\n          queue.push(nextNode);\r\n        }\r\n      }\r\n      if (col > 0) {\r\n        nextNode = grid[row][col - 1];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = closestNode;\r\n          queue.push(nextNode);\r\n        }\r\n      }\r\n      if (col < grid[0].length - 1) {\r\n        nextNode = grid[row][col + 1];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = closestNode;\r\n          queue.push(nextNode);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while(currentNode !== null){\r\n      nodesInShortestPathOrder.unshift(currentNode);\r\n      currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","// main dijkstra's function \r\nexport function dijkstra(grid, startNode, finishNode){\r\n    const visitedNodesInOrder = [];\r\n    startNode.distance = 0;\r\n    const unvisitedNodes = getAllNodes(grid);\r\n    while(!!unvisitedNodes.length){\r\n        sortNodesByDistance(unvisitedNodes);\r\n        const closestNode = unvisitedNodes.shift();\r\n        if(closestNode.isWall) continue;\r\n        if(closestNode.distance === Infinity) return visitedNodesInOrder;\r\n        closestNode.isVisited = true;\r\n        visitedNodesInOrder.push(closestNode);\r\n        if(closestNode === finishNode) return visitedNodesInOrder;\r\n        updateUnvisitedNeighbors(closestNode, grid);\r\n    }\r\n}\r\n// get all nodes of grid\r\nfunction getAllNodes(grid){\r\n    const nodes = [];\r\n    for(const row of grid){\r\n        for(const node of row){\r\n            nodes.push(node);\r\n        }\r\n    }\r\n    return nodes;\r\n}\r\n// sort the nodes by distance\r\nfunction sortNodesByDistance(unvisitedNodes){\r\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n// update unvisited neighbors\r\nfunction updateUnvisitedNeighbors(node, grid){\r\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n    for(const neighbor of unvisitedNeighbors){\r\n        neighbor.distance = node.distance + 1;\r\n        neighbor.previousNode = node;\r\n    }\r\n}\r\n// Find unvisited neighbor node\r\nfunction getUnvisitedNeighbors(node, grid){\r\n    const neighbors = [];\r\n    const {col, row} = node;\r\n    if(row > 0) neighbors.push(grid[row - 1][col]);\r\n    if(row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n    if(col > 0) neighbors.push(grid[row][col - 1]);\r\n    if(col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n    return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}\r\n\r\n// Find Shortest Path After the Dijkstra Function run using backtracking \r\nexport function getNodesInShortestPathOrder(finishNode){\r\n    const nodesInShortestPathOrder = [];\r\n    let currentNode = finishNode;\r\n    while(currentNode !== null){\r\n        nodesInShortestPathOrder.unshift(currentNode);\r\n        currentNode = currentNode.previousNode;\r\n    }\r\n    return nodesInShortestPathOrder;\r\n}\r\n","// main dfs function\r\nexport function dfs(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  const stack = [];\r\n  stack.push(startNode);\r\n  while (stack.length) {\r\n    const closestNode = stack.pop();\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n    if (\r\n      !closestNode.isWall &&\r\n      (closestNode.isStart || !closestNode.isVisited)\r\n    ) {\r\n      closestNode.isVisited = true;\r\n      visitedNodesInOrder.push(closestNode);\r\n      const {col, row} = closestNode;\r\n      let nextNode;\r\n      if(row > 0){\r\n        nextNode = grid[row - 1][col];\r\n        if(!nextNode.isVisited){\r\n          nextNode.previousNode = closestNode;\r\n          stack.push(nextNode);\r\n        }\r\n      }\r\n      if(row < grid.length - 1){\r\n        nextNode = grid[row + 1][col];\r\n        if(!nextNode.isVisited){\r\n          nextNode.previousNode = closestNode;\r\n          stack.push(nextNode);\r\n        }\r\n      }\r\n      if(col > 0){\r\n        nextNode = grid[row][col - 1];\r\n        if(!nextNode.isVisited){\r\n          nextNode.previousNode = closestNode;\r\n          stack.push(nextNode);\r\n        }\r\n      }\r\n      if(col < grid[0].length - 1){\r\n        nextNode = grid[row][col + 1];\r\n        if(!nextNode.isVisited){\r\n          nextNode.previousNode = closestNode;\r\n          stack.push(nextNode);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n","// Need Heuristic\r\nexport function astar(grid, startNode, finishNode){\r\n  //Working on it\r\n}\r\n\r\n\r\n\r\n// Find Shortest Path After the Dijkstra Function run using backtracking \r\nexport function getNodesInShortestPathOrder(finishNode){\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while(currentNode !== null){\r\n      nodesInShortestPathOrder.unshift(currentNode);\r\n      currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","import React from \"react\";\r\nimport { makeStyles } from \"@material-ui/core/styles\";\r\nimport AppBar from \"@material-ui/core/AppBar\";\r\nimport Toolbar from \"@material-ui/core/Toolbar\";\r\nimport Typography from \"@material-ui/core/Typography\";\r\nimport Button from \"@material-ui/core/Button\";\r\n\r\nconst useStyles = makeStyles((theme) => ({\r\n  root: {\r\n    flexGrow: 1,\r\n  },\r\n  title: {\r\n    flexGrow: 3,\r\n  },\r\n  subTitle: {\r\n    flexGrow: 1,\r\n  },\r\n}));\r\n\r\nexport default function ButtonAppBar() {\r\n  const classes = useStyles();\r\n\r\n  return (\r\n    <div className={classes.root}>\r\n      <AppBar position=\"static\" style={{ background: \"#391763\" }}>\r\n        <Toolbar>\r\n          <Typography variant=\"h5\" className={classes.title}>\r\n            Path Finding\r\n          </Typography>\r\n\r\n          <Button\r\n            variant=\"variant\"\r\n            style={{\r\n              padding: \"13px 16px\",\r\n              backgroundColor: \"#069983\",\r\n              color: \"#FFFFFF\",\r\n              fontSize: \"15px\",\r\n            }}\r\n            className={classes.subTitle}\r\n          >\r\n            Visualize!\r\n          </Button>\r\n\r\n          <Button\r\n            variant=\"variant\"\r\n            style={{ color: \"#FFFFFF\" }}\r\n            className={classes.subTitle}\r\n          >\r\n            Algorithm\r\n          </Button>\r\n\r\n          <Button\r\n            variant=\"variant\"\r\n            style={{ color: \"#FFFFFF\" }}\r\n            className={classes.subTitle}\r\n          >\r\n            Mazes & Pattern\r\n          </Button>\r\n\r\n          <Button\r\n            variant=\"variant\"\r\n            style={{ color: \"#FFFFFF\" }}\r\n            className={classes.subTitle}\r\n          >\r\n            Speed\r\n          </Button>\r\n\r\n          <Typography variant=\"h6\" className={classes.subTitle}>\r\n            Time Taken: 10ms\r\n          </Typography>\r\n        </Toolbar>\r\n      </AppBar>\r\n    </div>\r\n  );\r\n}\r\n","import React, { Component } from \"react\";\r\nimport Node from \"./Node/Node\";\r\nimport {\r\n  breadthFirstSearch,\r\n  getNodesInShortestPathOrder,\r\n} from \"../Algorithms/breadthFirstSearch\";\r\nimport { dijkstra } from \"../Algorithms/dijkastra\";\r\nimport { dfs } from \"../Algorithms/dfs\";\r\nimport { astar } from \"../Algorithms/astar\";\r\nimport \"./Path_visualizer.css\";\r\n\r\nimport UI from \"./ui\";\r\n\r\nconst START_NODE_ROW = 10;\r\nconst START_NODE_COL = 15;\r\nconst FINISH_NODE_ROW = 10;\r\nconst FINISH_NODE_COL = 35;\r\n\r\nexport default class Path_visualizer extends Component {\r\n  constructor() {\r\n    super();\r\n    this.state = {\r\n      grid: [],\r\n      mouseIsPressed: false,\r\n    };\r\n  }\r\n  componentDidMount() {\r\n    const grid = getInitialGrid();\r\n    this.setState({ grid });\r\n  }\r\n\r\n  handleMouseDown(row, col) {\r\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n    this.setState({ grid: newGrid, mouseIsPressed: true });\r\n    // console.log(\"Mouse Down\");\r\n  }\r\n\r\n  handleMouseEnter(row, col) {\r\n    if (!this.state.mouseIsPressed) return;\r\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n    this.setState({ grid: newGrid });\r\n    // console.log(\"Mouse Enter\");\r\n  }\r\n\r\n  handleMouseUp() {\r\n    this.setState({ mouseIsPressed: false });\r\n    // console.log(\"Mouse Up\");\r\n  }\r\n\r\n  animateAlgo(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n      if (i === visitedNodesInOrder.length) {\r\n        setTimeout(() => {\r\n          this.animateShortestPath(nodesInShortestPathOrder);\r\n        }, 25 * i);\r\n        return;\r\n      }\r\n      setTimeout(() => {\r\n        const node = visitedNodesInOrder[i];\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node-visited\";\r\n      }, 25 * i);\r\n    }\r\n  }\r\n\r\n  animateShortestPath(nodesInShortestPathOrder) {\r\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n      setTimeout(() => {\r\n        const node = nodesInShortestPathOrder[i];\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node-shortest-path\";\r\n      }, 25 * i);\r\n    }\r\n  }\r\n\r\n  visualize(algo) {\r\n    const { grid } = this.state;\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    let visitedNodesInOrder = \"\";\r\n\r\n    if (algo === dijkstra)\r\n      visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\r\n    else if (algo === breadthFirstSearch)\r\n      visitedNodesInOrder = breadthFirstSearch(grid, startNode, finishNode);\r\n    else if (algo === dfs)\r\n      visitedNodesInOrder = dfs(grid, startNode, finishNode);\r\n    else if (algo === astar)\r\n      visitedNodesInOrder = astar(grid, startNode, finishNode);\r\n\r\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n    this.animateAlgo(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  }\r\n\r\n  render() {\r\n    const { grid, mouseIsPressed } = this.state;\r\n\r\n    return (\r\n      <>\r\n        <UI />\r\n        <button onClick={() => this.visualize(dijkstra)}>Dijkstra</button>\r\n        <button onClick={() => this.visualize(breadthFirstSearch)}>\r\n          Breadth First Search\r\n        </button>\r\n        <button onClick={() => this.visualize(dfs)}>Depth First Search</button>\r\n        <button onClick={() => this.visualize(dfs)}>A *</button>\r\n        <div className=\"grid\">\r\n          {grid.map((row, rowIdx) => {\r\n            return (\r\n              <div key={rowIdx} className=\"rowid\">\r\n                {row.map((node, nodeIdx) => {\r\n                  const { row, col, isFinish, isStart, isWall } = node;\r\n                  return (\r\n                    <Node\r\n                      key={nodeIdx}\r\n                      col={col}\r\n                      isFinish={isFinish}\r\n                      isStart={isStart}\r\n                      row={row}\r\n                      isWall={isWall}\r\n                      mouseIsPressed={mouseIsPressed}\r\n                      onMouseDown={(row, col) => this.handleMouseDown(row, col)}\r\n                      onMouseEnter={(row, col) =>\r\n                        this.handleMouseEnter(row, col)\r\n                      }\r\n                      onMouseUp={() => this.handleMouseUp()}\r\n                    ></Node>\r\n                  );\r\n                })}\r\n              </div>\r\n            );\r\n          })}\r\n        </div>\r\n      </>\r\n    );\r\n  }\r\n}\r\n\r\nconst getInitialGrid = () => {\r\n  const grid = [];\r\n  for (let row = 0; row < 22; row++) {\r\n    const currentRow = [];\r\n    for (let col = 0; col < 60; col++) {\r\n      currentRow.push(createNode(col, row));\r\n    }\r\n    grid.push(currentRow);\r\n  }\r\n  return grid;\r\n};\r\n\r\nconst createNode = (col, row) => {\r\n  return {\r\n    col,\r\n    row,\r\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\r\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\r\n    distance: Infinity,\r\n    previousNode: null,\r\n  };\r\n};\r\n\r\nconst getNewGridWithWallToggled = (grid, row, col) => {\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n  const newNode = {\r\n    ...node,\r\n    isWall: !node.isWall,\r\n  };\r\n  newGrid[row][col] = newNode;\r\n  return newGrid;\r\n};\r\n","import React from 'react';\r\nimport './App.css';\r\nimport Path_visualizer from './Path_visualizer/Path_visualizer';\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <Path_visualizer></Path_visualizer>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","const reportWebVitals = onPerfEntry => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n      getCLS(onPerfEntry);\r\n      getFID(onPerfEntry);\r\n      getFCP(onPerfEntry);\r\n      getLCP(onPerfEntry);\r\n      getTTFB(onPerfEntry);\r\n    });\r\n  }\r\n};\r\n\r\nexport default reportWebVitals;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport reportWebVitals from './reportWebVitals';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}
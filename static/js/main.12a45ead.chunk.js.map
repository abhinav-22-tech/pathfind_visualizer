{"version":3,"sources":["maze/recursiveDivision.js","maze/verticalMaze.js","maze/horizontalMaze.js","PathVisualizer/Node/Node.jsx","Algorithms/dijkstra.js","Algorithms/astar.js","Algorithms/greedyBestFirstSearch.js","Algorithms/randomWalk.js","PathVisualizer/PathVisualizer.jsx","images/logo.svg","PathVisualizer/ui.js","Algorithms/breadthFirstSearch.js","Algorithms/dfs.js","maze/randomMaze.js","App.js","index.js"],"names":["walls","Node","this","props","col","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","row","extraClassName","id","className","Component","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","previousNode","getNeighbours","neighbours","neighbour","neighbourNotInUnvisitedNodes","heuristic","Math","abs","getRandomNeighbour","neighboursFilteredStartAndWall","neighboursFilteredVisited","floor","random","numNodesVisited","count","recursiveDivisionMaze","vertical","range","horizontal","getRecursiveWalls","len","result","i","dir","num","generateOddRandomNumber","addWall","slice","indexOf","array","max","randomNum","isStartFinish","tempWalls","temp","splice","generateRandomNumber","wall","verticalMaze","choice","getVerticalWalls","horizontalMaze","getHorizontalWalls","StyledMenu","styled","Menu","elevation","anchorOrigin","transformOrigin","borderRadius","minWidth","boxShadow","padding","fontSize","marginRight","theme","spacing","Navbar","state","algorithm","maze","speed","anchorEl","anchorE2","anchorE3","open","undefined","open2","open3","handleClick","event","setState","currentTarget","Boolean","handleClick2","handleClick3","handleClose","e","target","innerText","handleClose2","handleClose3","updateSpeed","AppBar","position","style","backgroundColor","Toolbar","IconButton","edge","src","logo","alt","width","height","Typography","variant","component","sx","flexGrow","Button","onClick","color","textTransform","endIcon","MenuListProps","MenuItem","value","Divider","my","ml","disableElevation","borderColor","visualize","generateMaze","clearGrid","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","PathVisualizer","animateRandomWalk","setTimeout","visualizingAlgorithm","document","getElementById","animateMaze","newGrid","getNewGridWithMaze","generatingMaze","mazeSpeed","mouseIsPressed","numRows","numColumns","getInitialGrid","getNewGridWithWallToggled","nodesInShortestPathOrder","animateShortestPath","algo","queue","nextNode","breadthFirstSearch","stack","pop","dfs","a","b","totalDistance","unshift","astar","greedyBFS","maxNodes","maxNodesVisitedTracker","loopTracker","randomNeighbour","nodesVisited","randomWalk","currentNode","getNodesInShortestPathOrder","animateAlgo","randomMaze","generateRandomMaze","generateRecursiveDivisionMaze","generateVerticalMaze","generateHorizontalMaze","toString","data","CssBaseline","bind","map","rowIdx","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","currentRow","createNode","newNode","App","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.12a45ead.chunk.js","sourcesContent":["let walls;\r\nexport function recursiveDivisionMaze(grid, startNode, finishNode) {\r\n  if (!startNode || !finishNode || startNode === finishNode) {\r\n    return false;\r\n  }\r\n  let vertical = range(grid[0].length);\r\n  let horizontal = range(grid.length);\r\n  walls = [];\r\n  getRecursiveWalls(vertical, horizontal, grid, startNode, finishNode);\r\n  return walls;\r\n}\r\n\r\nfunction range(len) {\r\n  let result = [];\r\n  for (let i = 0; i < len; i++) {\r\n    result.push(i);\r\n  }\r\n  return result;\r\n}\r\n\r\n//dir === 0 => Horizontal\r\n//dir === 1 => Vertical\r\n\r\nfunction getRecursiveWalls(vertical, horizontal, grid, startNode, finishNode) {\r\n  if (vertical.length < 2 || horizontal.length < 2) {\r\n    return;\r\n  }\r\n  let dir;\r\n  let num;\r\n  if (vertical.length > horizontal.length) {\r\n    dir = 0;\r\n    num = generateOddRandomNumber(vertical);\r\n  }\r\n  if (vertical.length <= horizontal.length) {\r\n    dir = 1;\r\n    num = generateOddRandomNumber(horizontal);\r\n  }\r\n\r\n  if (dir === 0) {\r\n    addWall(dir, num, vertical, horizontal, startNode, finishNode);\r\n    getRecursiveWalls(\r\n      vertical.slice(0, vertical.indexOf(num)),\r\n      horizontal,\r\n      grid,\r\n      startNode,\r\n      finishNode\r\n    );\r\n    getRecursiveWalls(\r\n      vertical.slice(vertical.indexOf(num) + 1),\r\n      horizontal,\r\n      grid,\r\n      startNode,\r\n      finishNode\r\n    );\r\n  } else {\r\n    addWall(dir, num, vertical, horizontal, startNode, finishNode);\r\n    getRecursiveWalls(\r\n      vertical,\r\n      horizontal.slice(0, horizontal.indexOf(num)),\r\n      grid,\r\n      startNode,\r\n      finishNode\r\n    );\r\n    getRecursiveWalls(\r\n      vertical,\r\n      horizontal.slice(horizontal.indexOf(num) + 1),\r\n      grid,\r\n      startNode,\r\n      finishNode\r\n    );\r\n  }\r\n}\r\n\r\nfunction generateOddRandomNumber(array) {\r\n  let max = array.length - 1;\r\n  let randomNum =\r\n    Math.floor(Math.random() * (max / 2)) +\r\n    Math.floor(Math.random() * (max / 2));\r\n  if (randomNum % 2 === 0) {\r\n    if (randomNum === max) {\r\n      randomNum -= 1;\r\n    } else {\r\n      randomNum += 1;\r\n    }\r\n  }\r\n  return array[randomNum];\r\n}\r\n\r\n//dir === 0 => Horizontal\r\n//dir === 1 => Vertical\r\n\r\nfunction addWall(dir, num, vertical, horizontal, startNode, finishNode) {\r\n  let isStartFinish = false;\r\n  let tempWalls = [];\r\n  if (dir === 0) {\r\n    if (horizontal.length === 2) return;\r\n    for (let temp of horizontal) {\r\n      if (\r\n        (temp === startNode.row && num === startNode.col) ||\r\n        (temp === finishNode.row && num === finishNode.col)\r\n      ) {\r\n        isStartFinish = true;\r\n        continue;\r\n      }\r\n      tempWalls.push([temp, num]);\r\n    }\r\n  } else {\r\n    if (vertical.length === 2) return;\r\n    for (let temp of vertical) {\r\n      if (\r\n        (num === startNode.row && temp === startNode.col) ||\r\n        (num === finishNode.row && temp === finishNode.col)\r\n      ) {\r\n        isStartFinish = true;\r\n        continue;\r\n      }\r\n      tempWalls.push([num, temp]);\r\n    }\r\n  }\r\n  if (!isStartFinish) {\r\n    tempWalls.splice(generateRandomNumber(tempWalls.length), 1);\r\n  }\r\n  for (let wall of tempWalls) {\r\n    walls.push(wall);\r\n  }\r\n}\r\n\r\nfunction generateRandomNumber(max) {\r\n  let randomNum =\r\n    Math.floor(Math.random() * (max / 2)) +\r\n    Math.floor(Math.random() * (max / 2));\r\n  if (randomNum % 2 !== 0) {\r\n    if (randomNum === max) {\r\n      randomNum -= 1;\r\n    } else {\r\n      randomNum += 1;\r\n    }\r\n  }\r\n  return randomNum;\r\n}\r\n","let walls;\r\nexport function verticalMaze(grid, startNode, finishNode) {\r\n  if (!startNode || !finishNode || startNode === finishNode) {\r\n    return false;\r\n  }\r\n  let vertical = range(grid[0].length);\r\n  let horizontal = range(grid.length);\r\n  walls = [];\r\n  getVerticalWalls(vertical, horizontal, startNode, finishNode);\r\n  return walls;\r\n}\r\n\r\nfunction range(len) {\r\n  let result = [];\r\n  for (let i = 0; i < len; i++) {\r\n    result.push(i);\r\n  }\r\n  return result;\r\n}\r\n\r\nfunction getVerticalWalls(vertical, horizontal, startNode, finishNode) {\r\n  if (vertical.length < 2) {\r\n    return;\r\n  }\r\n\r\n  let choice = Math.floor(Math.random() * 2);\r\n  for (let num of vertical) {\r\n    if (choice === 0 && num % 2 !== 0) {\r\n      addWall(num, horizontal, startNode, finishNode);\r\n    }\r\n    if (choice === 1 && num % 2 === 0) {\r\n      addWall(num, horizontal, startNode, finishNode);\r\n    }\r\n  }\r\n}\r\n\r\nfunction addWall(num, horizontal, startNode, finishNode) {\r\n  let isStartFinish = false;\r\n  let tempWalls = [];\r\n  for (let temp of horizontal) {\r\n    if (\r\n      (temp === startNode.row && num === startNode.col) ||\r\n      (temp === finishNode.row && num === finishNode.col)\r\n    ) {\r\n      isStartFinish = true;\r\n      continue;\r\n    }\r\n    tempWalls.push([temp, num]);\r\n  }\r\n  if (!isStartFinish) {\r\n    tempWalls.splice(Math.floor(Math.random() * tempWalls.length), 1);\r\n  }\r\n  for (let wall of tempWalls) {\r\n    walls.push(wall);\r\n  }\r\n}\r\n","let walls;\r\nexport function horizontalMaze(grid, startNode, finishNode) {\r\n  if (!startNode || !finishNode || startNode === finishNode) {\r\n    return false;\r\n  }\r\n  let vertical = range(grid[0].length);\r\n  let horizontal = range(grid.length);\r\n  walls = [];\r\n  getHorizontalWalls(vertical, horizontal, startNode, finishNode);\r\n  return walls;\r\n}\r\n\r\nfunction range(len) {\r\n  let result = [];\r\n  for (let i = 0; i < len; i++) {\r\n    result.push(i);\r\n  }\r\n  return result;\r\n}\r\n\r\nfunction getHorizontalWalls(vertical, horizontal, startNode, finishNode) {\r\n  if (horizontal.length < 2) {\r\n    return;\r\n  }\r\n\r\n  let choice = Math.floor(Math.random() * 2);\r\n  for (let num of horizontal) {\r\n    if (choice === 0 && num % 2 !== 0) {\r\n      addWall(num, vertical, startNode, finishNode);\r\n    }\r\n    if (choice === 1 && num % 2 === 0) {\r\n      addWall(num, vertical, startNode, finishNode);\r\n    }\r\n  }\r\n}\r\n\r\nfunction addWall(num, vertical, startNode, finishNode) {\r\n  let isStartFinish = false;\r\n  let tempWalls = [];\r\n  for (let temp of vertical) {\r\n    if (\r\n      (num === startNode.row && temp === startNode.col) ||\r\n      (num === finishNode.row && temp === finishNode.col)\r\n    ) {\r\n      isStartFinish = true;\r\n      continue;\r\n    }\r\n    tempWalls.push([num, temp]);\r\n  }\r\n  if (!isStartFinish) {\r\n    tempWalls.splice(Math.floor(Math.random() * tempWalls.length), 1);\r\n  }\r\n  for (let wall of tempWalls) {\r\n    walls.push(wall);\r\n  }\r\n}\r\n","import React, { Component } from \"react\";\r\n\r\nimport \"./Node.css\";\r\n\r\nexport default class Node extends Component {\r\n  render() {\r\n    const {\r\n      col,\r\n      isFinish,\r\n      isStart,\r\n      isWall,\r\n      onMouseDown,\r\n      onMouseEnter,\r\n      onMouseUp,\r\n      row,\r\n    } = this.props;\r\n    const extraClassName = isFinish\r\n      ? \"node-finish\"\r\n      : isStart\r\n      ? \"node-start\"\r\n      : isWall\r\n      ? \"node-wall\"\r\n      : \"\";\r\n\r\n    return (\r\n      <div\r\n        id={`node-${row}-${col}`}\r\n        className={`node ${extraClassName}`}\r\n        onMouseDown={() => onMouseDown(row, col)}\r\n        onMouseEnter={() => onMouseEnter(row, col)}\r\n        onMouseUp={() => onMouseUp(row, col)}\r\n      ></div>\r\n    );\r\n  }\r\n}\r\n","// main dijkstra's function \r\nexport function dijkstra(grid, startNode, finishNode){\r\n    const visitedNodesInOrder = [];\r\n    startNode.distance = 0;\r\n    const unvisitedNodes = getAllNodes(grid);\r\n    while(!!unvisitedNodes.length){\r\n        sortNodesByDistance(unvisitedNodes);\r\n        const closestNode = unvisitedNodes.shift();\r\n        if(closestNode.isWall) continue;\r\n        if(closestNode.distance === Infinity) return visitedNodesInOrder;\r\n        closestNode.isVisited = true;\r\n        visitedNodesInOrder.push(closestNode);\r\n        if(closestNode === finishNode) return visitedNodesInOrder;\r\n        updateUnvisitedNeighbors(closestNode, grid);\r\n    }\r\n}\r\n// get all nodes of grid\r\nfunction getAllNodes(grid){\r\n    const nodes = [];\r\n    for(const row of grid){\r\n        for(const node of row){\r\n            nodes.push(node);\r\n        }\r\n    }\r\n    return nodes;\r\n}\r\n// sort the nodes by distance\r\nfunction sortNodesByDistance(unvisitedNodes){\r\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n// update unvisited neighbors\r\nfunction updateUnvisitedNeighbors(node, grid){\r\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n    for(const neighbor of unvisitedNeighbors){\r\n        neighbor.distance = node.distance + 1;\r\n        neighbor.previousNode = node;\r\n    }\r\n}\r\n// Find unvisited neighbor node\r\nfunction getUnvisitedNeighbors(node, grid){\r\n    const neighbors = [];\r\n    const {col, row} = node;\r\n    if(row > 0) neighbors.push(grid[row - 1][col]);\r\n    if(row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n    if(col > 0) neighbors.push(grid[row][col - 1]);\r\n    if(col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n    return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}\r\n\r\n// Find Shortest Path After the Dijkstra Function run using backtracking \r\nexport function getNodesInShortestPathOrder(finishNode){\r\n    const nodesInShortestPathOrder = [];\r\n    let currentNode = finishNode;\r\n    while(currentNode !== null){\r\n        nodesInShortestPathOrder.unshift(currentNode);\r\n        currentNode = currentNode.previousNode;\r\n    }\r\n    return nodesInShortestPathOrder;\r\n}\r\n","export function astar(grid, startNode, finishNode) {\r\n  if (!startNode || !finishNode || startNode === finishNode) {\r\n    return false;\r\n  }\r\n  let unvisitedNodes = []; //open list\r\n  let visitedNodesInOrder = []; //closed list\r\n  startNode.distance = 0;\r\n  unvisitedNodes.push(startNode);\r\n\r\n  while (unvisitedNodes.length !== 0) {\r\n    unvisitedNodes.sort((a, b) => a.totalDistance - b.totalDistance);\r\n    let closestNode = unvisitedNodes.shift();\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n\r\n    let neighbours = getNeighbours(closestNode, grid);\r\n    for (let neighbour of neighbours) {\r\n      let distance = closestNode.distance + 1;\r\n      //f(n) = g(n) + h(n)\r\n      if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes)) {\r\n        unvisitedNodes.unshift(neighbour);\r\n        neighbour.distance = distance;\r\n        neighbour.totalDistance =\r\n          distance + heuristic(neighbour, finishNode);\r\n        neighbour.previousNode = closestNode;\r\n      } else if (distance < neighbour.distance) {\r\n        neighbour.distance = distance;\r\n        neighbour.totalDistance =\r\n          distance + heuristic(neighbour, finishNode);\r\n        neighbour.previousNode = closestNode;\r\n      }\r\n    }\r\n  }\r\n  return visitedNodesInOrder;\r\n}\r\n\r\nfunction getNeighbours(node, grid) {\r\n  let neighbours = [];\r\n  let { row, col } = node;\r\n  if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\r\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\r\n  if (col !== 0) neighbours.push(grid[row][col - 1]);\r\n  if (row !== 0) neighbours.push(grid[row - 1][col]);\r\n  return neighbours.filter(\r\n    (neighbour) => !neighbour.isWall && !neighbour.isVisited\r\n  );\r\n}\r\n\r\nfunction neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\r\n  for (let node of unvisitedNodes) {\r\n    if (node.row === neighbour.row && node.col === neighbour.col) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nfunction heuristic(node, finishNode) {\r\n  let x = Math.abs(node.row - finishNode.row);\r\n  let y = Math.abs(node.col - finishNode.col);\r\n  return x + y;\r\n}\r\n\r\n\r\n","export function greedyBFS(grid, startNode, finishNode) {\r\n  if (!startNode || !finishNode || startNode === finishNode) {\r\n    return false;\r\n  }\r\n  let unvisitedNodes = []; //open list\r\n  let visitedNodesInOrder = []; //closed list\r\n  startNode.distance = 0;\r\n  unvisitedNodes.push(startNode);\r\n\r\n  while (unvisitedNodes.length !== 0) {\r\n    unvisitedNodes.sort((a, b) => a.totalDistance - b.totalDistance);\r\n    let closestNode = unvisitedNodes.shift();\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n\r\n    let neighbours = getNeighbours(closestNode, grid);\r\n    for (let neighbour of neighbours) {\r\n      let distance = closestNode.distance + 1;\r\n      //f(n) = h(n)\r\n      if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes)) {\r\n        unvisitedNodes.unshift(neighbour);\r\n        neighbour.distance = distance;\r\n        neighbour.totalDistance = heuristic(neighbour, finishNode);\r\n        neighbour.previousNode = closestNode;\r\n      } else if (distance < neighbour.distance) {\r\n        neighbour.distance = distance;\r\n        neighbour.totalDistance = heuristic(neighbour, finishNode);\r\n        neighbour.previousNode = closestNode;\r\n      }\r\n    }\r\n  }\r\n  return visitedNodesInOrder;\r\n}\r\n\r\nfunction getNeighbours(node, grid) {\r\n  let neighbours = [];\r\n  let { row, col } = node;\r\n  if (row !== 0) neighbours.push(grid[row - 1][col]);\r\n  if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\r\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\r\n  if (col !== 0) neighbours.push(grid[row][col - 1]);\r\n  return neighbours.filter(\r\n    (neighbour) => !neighbour.isWall && !neighbour.isVisited\r\n  );\r\n}\r\n\r\nfunction heuristic(node, finishNode) {\r\n  let x = Math.abs(node.row - finishNode.row);\r\n  let y = Math.abs(node.col - finishNode.col);\r\n  return x + y;\r\n}\r\n\r\nfunction neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\r\n  for (let node of unvisitedNodes) {\r\n    if (node.row === neighbour.row && node.col === neighbour.col) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\n","export function randomWalk(grid, startNode, finishNode) {\r\n  // if (!startNode || !finishNode || startNode === finishNode) {\r\n  //   return false;\r\n  // }\r\n  let visitedNodesInOrder = [];\r\n  let closestNode = startNode;\r\n  let maxNodes = grid.length * grid[0].length;\r\n  let maxNodesVisitedTracker = 0;\r\n  let loopTracker = 0;\r\n  while (true) {\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n    let randomNeighbour = getRandomNeighbour(closestNode, grid, finishNode);\r\n    let nodesVisited = numNodesVisited(grid);\r\n    if (nodesVisited === maxNodes - 2) {\r\n      return visitedNodesInOrder;\r\n    }\r\n    if (nodesVisited > maxNodesVisitedTracker) {\r\n      maxNodesVisitedTracker = nodesVisited;\r\n      loopTracker = 0;\r\n    } else if ((nodesVisited = maxNodesVisitedTracker)) {\r\n      loopTracker += 1;\r\n      if (loopTracker > 1000) {\r\n        return visitedNodesInOrder;\r\n      }\r\n    }\r\n    randomNeighbour.previousNode = closestNode;\r\n    closestNode = randomNeighbour;\r\n  }\r\n}\r\n\r\nfunction getRandomNeighbour(node, grid, finishNode) {\r\n  let neighbours = [];\r\n  let { row, col } = node;\r\n  if (row !== 0) neighbours.push(grid[row - 1][col]);\r\n  if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\r\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\r\n  if (col !== 0) neighbours.push(grid[row][col - 1]);\r\n  let neighboursFilteredStartAndWall = neighbours.filter(\r\n    (neighbour) => !neighbour.isStart && !neighbour.isWall\r\n  );\r\n  let neighboursFilteredVisited = neighboursFilteredStartAndWall.filter(\r\n    (neighbour) => !neighbour.isVisited\r\n  );\r\n  if (neighboursFilteredVisited.length > 0) {\r\n    return neighboursFilteredVisited[\r\n      Math.floor(Math.random() * neighboursFilteredVisited.length)\r\n    ];\r\n  }\r\n  return neighboursFilteredStartAndWall[\r\n    Math.floor(Math.random() * neighboursFilteredStartAndWall.length)\r\n  ];\r\n}\r\n\r\nfunction numNodesVisited(grid) {\r\n  let count = 0;\r\n  for (let row of grid) {\r\n    for (let node of row) {\r\n      if (node.isVisited || node.isWall) count += 1;\r\n    }\r\n  }\r\n  return count;\r\n}\r\n","import React, { Component } from \"react\";\r\nimport Node from \"./Node/Node\";\r\n\r\nimport {\r\n  breadthFirstSearch,\r\n  getNodesInShortestPathOrder,\r\n} from \"../Algorithms/breadthFirstSearch\";\r\nimport { dijkstra } from \"../Algorithms/dijkstra\";\r\nimport { dfs } from \"../Algorithms/dfs\";\r\nimport { astar } from \"../Algorithms/astar\";\r\nimport { greedyBFS } from \"../Algorithms/greedyBestFirstSearch\";\r\nimport { randomWalk } from \"../Algorithms/randomWalk\";\r\n\r\nimport { randomMaze } from \"../maze/randomMaze\";\r\nimport { recursiveDivisionMaze } from \"../maze/recursiveDivision\";\r\nimport { verticalMaze } from \"../maze/verticalMaze\";\r\nimport { horizontalMaze } from \"../maze/horizontalMaze\";\r\n\r\nimport \"./PathVisualizer.css\";\r\nimport { CssBaseline } from \"@material-ui/core\";\r\nimport Navbar from \"./ui\";\r\n\r\nconst START_NODE_ROW = 10;\r\nconst START_NODE_COL = 15;\r\nconst FINISH_NODE_ROW = 10;\r\nconst FINISH_NODE_COL = 35;\r\nlet visitedNodesInOrder;\r\n\r\nexport default class PathVisualizer extends Component {\r\n  constructor() {\r\n    super();\r\n    this.state = {\r\n      grid: [],\r\n      mouseIsPressed: false,\r\n      visualizingAlgorithm: false,\r\n      generatingMaze: false,\r\n      numRows: 24,\r\n      numColumns: 60,\r\n      speed: 10,\r\n      mazeSpeed: 10,\r\n    };\r\n  }\r\n  componentDidMount() {\r\n    const grid = getInitialGrid(this.state.numRows, this.state.numColumns);\r\n    this.setState({ grid });\r\n  }\r\n\r\n  handleMouseDown(row, col) {\r\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n    this.setState({ grid: newGrid, mouseIsPressed: true });\r\n  }\r\n\r\n  handleMouseEnter(row, col) {\r\n    if (!this.state.mouseIsPressed) return;\r\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n    this.setState({ grid: newGrid });\r\n  }\r\n\r\n  handleMouseUp() {\r\n    this.setState({ mouseIsPressed: false });\r\n  }\r\n\r\n  animateAlgo(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n      if (i === visitedNodesInOrder.length) {\r\n        setTimeout(() => {\r\n          this.animateShortestPath(nodesInShortestPathOrder);\r\n        }, this.state.speed * i);\r\n        return;\r\n      }\r\n      setTimeout(() => {\r\n        const node = visitedNodesInOrder[i];\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node-visited\";\r\n      }, this.state.speed * i);\r\n    }\r\n  }\r\n\r\n  animateShortestPath(nodesInShortestPathOrder) {\r\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n      setTimeout(() => {\r\n        const node = nodesInShortestPathOrder[i];\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node-shortest-path\";\r\n      }, this.state.speed * i);\r\n    }\r\n  }\r\n\r\n  animateRandomWalk = (visitedNodesInOrder) => {\r\n    for (let i = 1; i <= visitedNodesInOrder.length; i++) {\r\n      if (i === visitedNodesInOrder.length) {\r\n        setTimeout(() => {\r\n          this.setState({ visualizingAlgorithm: false });\r\n        }, i * this.state.speed);\r\n        return;\r\n      }\r\n      let node = visitedNodesInOrder[i];\r\n      if (i === visitedNodesInOrder.length - 1) {\r\n        setTimeout(() => {\r\n          //finish node\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node-finish-reached\";\r\n        }, i * this.state.speed);\r\n        continue;\r\n      }\r\n      setTimeout(() => {\r\n        //visited node\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node-visited\";\r\n      }, i * this.state.speed);\r\n    }\r\n  };\r\n\r\n  visualize(algo) {\r\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\r\n      return;\r\n    }\r\n    if (algo === \"Algorithm\") return;\r\n\r\n    const { grid } = this.state;\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    visitedNodesInOrder = \"\";\r\n\r\n    if (algo === \"Dijkstra\")\r\n      visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\r\n    else if (algo === \"Breadth First Search\")\r\n      visitedNodesInOrder = breadthFirstSearch(grid, startNode, finishNode);\r\n    else if (algo === \"Depth First Search\")\r\n      visitedNodesInOrder = dfs(grid, startNode, finishNode);\r\n    else if (algo === \"A *\")\r\n      visitedNodesInOrder = astar(grid, startNode, finishNode);\r\n    else if (algo === \"Greedy Best First Search\")\r\n      visitedNodesInOrder = greedyBFS(grid, startNode, finishNode);\r\n    else if (algo === \"Random Walk\")\r\n      visitedNodesInOrder = randomWalk(grid, startNode, finishNode);\r\n\r\n    if (algo === \"Random Walk\") {\r\n      this.animateRandomWalk(visitedNodesInOrder);\r\n    } else {\r\n      const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n      this.animateAlgo(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    }\r\n  }\r\n\r\n  animateMaze = (walls) => {\r\n    for (let i = 0; i <= walls.length; i++) {\r\n      if (i === walls.length) {\r\n        setTimeout(() => {\r\n          this.clearGrid();\r\n          let newGrid = getNewGridWithMaze(this.state.grid, walls);\r\n          this.setState({ grid: newGrid, generatingMaze: false });\r\n        }, i * this.state.mazeSpeed);\r\n        return;\r\n      }\r\n      let wall = walls[i];\r\n      let node = this.state.grid[wall[0]][wall[1]];\r\n      setTimeout(() => {\r\n        //Walls\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node-wall-animated\";\r\n      }, i * this.state.mazeSpeed);\r\n    }\r\n  };\r\n\r\n  generateRandomMaze() {\r\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\r\n      return;\r\n    }\r\n    this.setState({ generatingMaze: true });\r\n    setTimeout(() => {\r\n      const { grid } = this.state;\r\n      const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n      const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n      const walls = randomMaze(grid, startNode, finishNode);\r\n      this.animateMaze(walls);\r\n    }, this.state.mazeSpeed);\r\n  }\r\n\r\n  generateRecursiveDivisionMaze() {\r\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\r\n      return;\r\n    }\r\n    this.setState({ generatingMaze: true });\r\n    setTimeout(() => {\r\n      const { grid } = this.state;\r\n      const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n      const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n      const walls = recursiveDivisionMaze(grid, startNode, finishNode);\r\n      this.animateMaze(walls);\r\n    }, this.state.mazeSpeed);\r\n  }\r\n\r\n  generateVerticalMaze() {\r\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\r\n      return;\r\n    }\r\n    this.setState({ generatingMaze: true });\r\n    setTimeout(() => {\r\n      const { grid } = this.state;\r\n      const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n      const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n      const walls = verticalMaze(grid, startNode, finishNode);\r\n      this.animateMaze(walls);\r\n    }, this.state.mazeSpeed);\r\n  }\r\n\r\n  generateHorizontalMaze() {\r\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\r\n      return;\r\n    }\r\n    this.setState({ generatingMaze: true });\r\n    setTimeout(() => {\r\n      const { grid } = this.state;\r\n      const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n      const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n      const walls = horizontalMaze(grid, startNode, finishNode);\r\n      this.animateMaze(walls);\r\n    }, this.state.mazeSpeed);\r\n  }\r\n\r\n  generateMaze(maze) {\r\n    if (maze === \"Random Maze\") this.generateRandomMaze();\r\n    else if (maze === \"Recursive Division Maze\")\r\n      this.generateRecursiveDivisionMaze();\r\n    else if (maze === \"Vertical Division Maze\") this.generateVerticalMaze();\r\n    else if (maze === \"Horizontal Division Maze\") this.generateHorizontalMaze();\r\n  }\r\n\r\n  clearGrid() {\r\n    if (this.state.visualizingAlgorithm || this.state.generatingMaze) {\r\n      return;\r\n    }\r\n\r\n    const grid = getInitialGrid(this.state.numRows, this.state.numColumns);\r\n    this.setState({ grid });\r\n\r\n    this.setState({ visualizingAlgorithm: false });\r\n\r\n    for (let i = 0; i <= visitedNodesInOrder.toString().length; i++) {\r\n      if (visitedNodesInOrder[i] === undefined) {\r\n        return;\r\n      } else {\r\n        const node = visitedNodesInOrder[i];\r\n\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node\";\r\n\r\n        document.getElementById(\r\n          `node-${START_NODE_ROW}-${START_NODE_COL}`\r\n        ).className = \"node node-start\";\r\n\r\n        document.getElementById(\r\n          `node-${FINISH_NODE_ROW}-${FINISH_NODE_COL}`\r\n        ).className = \"node node-finish\";\r\n      }\r\n    }\r\n  }\r\n\r\n  updateSpeed(data) {\r\n    let value = 10;\r\n    if (data === \"Slow\") {\r\n      value = 50;\r\n    } else if (data === \"Medium\") {\r\n      value = 25;\r\n    } else if (data === \"Fast\" || data === \"Speed\") {\r\n      value = 10;\r\n    }\r\n    this.setState({ speed: value });\r\n  }\r\n\r\n  render() {\r\n    const { grid, mouseIsPressed } = this.state;\r\n\r\n    return (\r\n      <>\r\n        <CssBaseline />\r\n\r\n        <Navbar\r\n          visualize={this.visualize.bind(this)}\r\n          generateMaze={this.generateMaze.bind(this)}\r\n          clearGrid={this.clearGrid.bind(this)}\r\n          updateSpeed={this.updateSpeed.bind(this)}\r\n        />\r\n        <div className=\"grid\">\r\n          {grid.map((row, rowIdx) => {\r\n            return (\r\n              <div key={rowIdx} className=\"rowid\">\r\n                {row.map((node, nodeIdx) => {\r\n                  const { row, col, isFinish, isStart, isWall } = node;\r\n                  return (\r\n                    <Node\r\n                      key={nodeIdx}\r\n                      col={col}\r\n                      isFinish={isFinish}\r\n                      isStart={isStart}\r\n                      row={row}\r\n                      isWall={isWall}\r\n                      mouseIsPressed={mouseIsPressed}\r\n                      onMouseDown={(row, col) => this.handleMouseDown(row, col)}\r\n                      onMouseEnter={(row, col) =>\r\n                        this.handleMouseEnter(row, col)\r\n                      }\r\n                      onMouseUp={() => this.handleMouseUp()}\r\n                    ></Node>\r\n                  );\r\n                })}\r\n              </div>\r\n            );\r\n          })}\r\n        </div>\r\n      </>\r\n    );\r\n  }\r\n}\r\n\r\nconst getInitialGrid = (numRows, numColumns) => {\r\n  const grid = [];\r\n  for (let row = 0; row < numRows; row++) {\r\n    const currentRow = [];\r\n    for (let col = 0; col < numColumns; col++) {\r\n      currentRow.push(createNode(col, row));\r\n    }\r\n    grid.push(currentRow);\r\n  }\r\n  return grid;\r\n};\r\n\r\nconst createNode = (col, row) => {\r\n  return {\r\n    col,\r\n    row,\r\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\r\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\r\n    distance: Infinity,\r\n    previousNode: null,\r\n  };\r\n};\r\n\r\nconst getNewGridWithWallToggled = (grid, row, col) => {\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n  const newNode = {\r\n    ...node,\r\n    isWall: !node.isWall,\r\n  };\r\n  newGrid[row][col] = newNode;\r\n  return newGrid;\r\n};\r\n\r\n// const getNewGridWithWalls = (grid, row, col) => {\r\n//   let newGrid = grid.slice();\r\n//   let node = grid[row][col];\r\n//   let newNode = {\r\n//     ...node,\r\n//     isWall: !node.isWall,\r\n//   };\r\n//   newGrid[row][col] = newNode;\r\n//   return newGrid;\r\n// };\r\n\r\nconst getNewGridWithMaze = (grid, walls) => {\r\n  let newGrid = grid.slice();\r\n  for (let wall of walls) {\r\n    let node = grid[wall[0]][wall[1]];\r\n    let newNode = {\r\n      ...node,\r\n      isWall: true,\r\n    };\r\n    newGrid[wall[0]][wall[1]] = newNode;\r\n  }\r\n  return newGrid;\r\n};\r\n","export default __webpack_public_path__ + \"static/media/logo.ab9bbf88.svg\";","// import { Icon } from \"@material-ui/core\";\r\nimport React, { Component } from \"react\";\r\nimport {\r\n  AppBar,\r\n  Toolbar,\r\n  IconButton,\r\n  Typography,\r\n  Button,\r\n  Menu,\r\n  MenuItem,\r\n  Divider,\r\n} from \"@mui/material\";\r\nimport KeyboardArrowDown from \"@material-ui/icons/KeyboardArrowDown\";\r\nimport { styled } from \"@material-ui/core\";\r\n\r\nimport logo from \"../images/logo.svg\";\r\n\r\nconst StyledMenu = styled((props) => (\r\n  <Menu\r\n    elevation={0}\r\n    anchorOrigin={{\r\n      vertical: \"bottom\",\r\n      horizontal: \"right\",\r\n    }}\r\n    transformOrigin={{\r\n      vertical: \"top\",\r\n      horizontal: \"right\",\r\n    }}\r\n    {...props}\r\n  />\r\n))(({ theme }) => ({\r\n  \"& .MuiPaper-root\": {\r\n    borderRadius: 6,\r\n    minWidth: 200,\r\n    boxShadow:\r\n      \"rgb(255, 255, 255) 0px 0px 0px 0px, rgba(0, 0, 0, 0.05) 0px 0px 0px 1px, rgba(0, 0, 0, 0.1) 0px 10px 15px -3px, rgba(0, 0, 0, 0.05) 0px 4px 6px -2px\",\r\n    \"& .MuiMenu-list\": {\r\n      padding: \"5px 0\",\r\n    },\r\n    \"& .MuiMenuItem-root\": {\r\n      \"& .MuiSvgIcon-root\": {\r\n        fontSize: 18,\r\n        marginRight: theme.spacing(1.5),\r\n      },\r\n    },\r\n  },\r\n}));\r\n\r\nclass Navbar extends Component {\r\n  state = {\r\n    algorithm: \"Algorithm\",\r\n    maze: \"Maze\",\r\n    speed: \"Speed\",\r\n    anchorEl: null,\r\n    anchorE2: null,\r\n    anchorE3: null,\r\n    open: undefined,\r\n    open2: undefined,\r\n    open3: undefined,\r\n  };\r\n\r\n  handleClick = (event) => {\r\n    this.setState({ anchorEl: event.currentTarget }, () => {\r\n      this.setState({ open: Boolean(this.state.anchorEl) });\r\n    });\r\n  };\r\n  handleClick2 = (event) => {\r\n    this.setState({ anchorE2: event.currentTarget }, () => {\r\n      this.setState({ open2: Boolean(this.state.anchorE2) });\r\n    });\r\n  };\r\n  handleClick3 = (event) => {\r\n    this.setState({ anchorE3: event.currentTarget }, () => {\r\n      this.setState({ open3: Boolean(this.state.anchorE3) });\r\n    });\r\n  };\r\n\r\n  handleClose = (e) => {\r\n    this.setState({ open: undefined }, () => {\r\n      this.setState({ anchorEl: null });\r\n    });\r\n    this.setState({ algorithm: e.target.innerText });\r\n  };\r\n  handleClose2 = (e) => {\r\n    this.setState({ open2: undefined }, () => {\r\n      this.setState({ anchorE2: null });\r\n    });\r\n    this.setState({ maze: e.target.innerText });\r\n  };\r\n  handleClose3 = (e) => {\r\n    this.setState({ open3: undefined }, () => {\r\n      this.setState({ anchorE3: null });\r\n    });\r\n    this.setState({ speed: e.target.innerText }, () => {\r\n      this.props.updateSpeed(this.state.speed);\r\n    });\r\n  };\r\n\r\n  render() {\r\n    return (\r\n      <div>\r\n        <AppBar position=\"static\" style={{ backgroundColor: \"#050A30\" }}>\r\n          <Toolbar>\r\n            <IconButton edge=\"start\" aria-label=\"app\">\r\n              <img\r\n                src={logo}\r\n                alt=\"logo\"\r\n                style={{ width: \"12rem\", height: \"auto\" }}\r\n              />\r\n            </IconButton>\r\n            <Typography\r\n              variant=\"h6\"\r\n              component=\"div\"\r\n              sx={{ flexGrow: 1 }}\r\n            ></Typography>\r\n            <Button\r\n              // sx={{ flexGrow: 1 }}\r\n              id=\"demo-customized-button\"\r\n              aria-controls=\"demo-customized-menu\"\r\n              aria-haspopup=\"true\"\r\n              aria-expanded={this.state.open ? \"true\" : undefined}\r\n              variant=\"contained\"\r\n              onClick={this.handleClick}\r\n              style={{\r\n                backgroundColor: \"white\",\r\n                color: \"#050A30\",\r\n                fontSize: \"16px\",\r\n                textTransform: \"none\",\r\n              }}\r\n              endIcon={<KeyboardArrowDown />}\r\n            >\r\n              {this.state.algorithm}\r\n            </Button>\r\n            <StyledMenu\r\n              id=\"demo-customized-menu\"\r\n              MenuListProps={{\r\n                \"aria-labelledby\": \"demo-customized-button\",\r\n              }}\r\n              anchorEl={this.state.anchorEl}\r\n              open={this.state.open}\r\n            >\r\n              <MenuItem\r\n                onClick={this.handleClose}\r\n                key=\"Dijkstra\"\r\n                value=\"Dijkstra\"\r\n              >\r\n                Dijkstra\r\n              </MenuItem>\r\n              <MenuItem\r\n                onClick={this.handleClose}\r\n                value=\"Breadth First Search\"\r\n                key=\"Breadth First Search\"\r\n              >\r\n                Breadth First Search\r\n              </MenuItem>\r\n\r\n              <MenuItem\r\n                onClick={this.handleClose}\r\n                value=\"Depth First Search\"\r\n                key=\"Depth First Search\"\r\n              >\r\n                Depth First Search\r\n              </MenuItem>\r\n              <Divider sx={{ my: 0.5 }} />\r\n              <MenuItem onClick={this.handleClose} value=\"A *\" key=\"A *\">\r\n                A *\r\n              </MenuItem>\r\n              <MenuItem\r\n                onClick={this.handleClose}\r\n                value=\"Greedy Best First Search\"\r\n                key=\"Greedy Best First Search\"\r\n              >\r\n                Greedy Best First Search\r\n              </MenuItem>\r\n              <MenuItem\r\n                onClick={this.handleClose}\r\n                value=\"Random Walk\"\r\n                key=\"Random Walk\"\r\n              >\r\n                Random Walk\r\n              </MenuItem>\r\n            </StyledMenu>\r\n\r\n            <Button\r\n              sx={{ ml: 2 }}\r\n              id=\"demo-customized-button-2\"\r\n              aria-controls=\"demo-customized-menu-2\"\r\n              aria-haspopup=\"true\"\r\n              aria-expanded={this.state.open2 ? \"true\" : undefined}\r\n              variant=\"contained\"\r\n              disableElevation\r\n              onClick={this.handleClick2}\r\n              style={{\r\n                backgroundColor: \"blue\",\r\n                color: \"white\",\r\n                textTransform: \"none\",\r\n              }}\r\n              endIcon={<KeyboardArrowDown />}\r\n            >\r\n              {this.state.maze}\r\n            </Button>\r\n            <StyledMenu\r\n              id=\"demo-customized-menu-2\"\r\n              MenuListProps={{\r\n                \"aria-labelledby\": \"demo-customized-button-2\",\r\n              }}\r\n              anchorEl={this.state.anchorE2}\r\n              open={this.state.open2}\r\n            >\r\n              <MenuItem onClick={this.handleClose2}>Random Maze</MenuItem>\r\n              <MenuItem onClick={this.handleClose2}>\r\n                Recursive Division Maze\r\n              </MenuItem>\r\n\r\n              <MenuItem onClick={this.handleClose2}>\r\n                Vertical Division Maze\r\n              </MenuItem>\r\n              <MenuItem onClick={this.handleClose2}>\r\n                Horizontal Division Maze\r\n              </MenuItem>\r\n            </StyledMenu>\r\n\r\n            <Button\r\n              sx={{ ml: 2 }}\r\n              id=\"demo-customized-button-3\"\r\n              aria-controls=\"demo-customized-menu-3\"\r\n              aria-haspopup=\"true\"\r\n              aria-expanded={this.state.open3 ? \"true\" : undefined}\r\n              variant=\"contained\"\r\n              disableElevation\r\n              onClick={this.handleClick3}\r\n              // onChange={() => this.props.updateSpeed(this.state.speed)}\r\n              style={{\r\n                backgroundColor: \"orange\",\r\n                color: \"white\",\r\n                textTransform: \"none\",\r\n              }}\r\n              endIcon={<KeyboardArrowDown />}\r\n            >\r\n              {this.state.speed}\r\n            </Button>\r\n            <StyledMenu\r\n              id=\"demo-customized-menu-3\"\r\n              MenuListProps={{\r\n                \"aria-labelledby\": \"demo-customized-button-3\",\r\n              }}\r\n              anchorEl={this.state.anchorE3}\r\n              open={this.state.open3}\r\n            >\r\n              <MenuItem onClick={this.handleClose3}>Slow</MenuItem>\r\n              <MenuItem onClick={this.handleClose3}>Medium</MenuItem>\r\n              <MenuItem onClick={this.handleClose3}>Fast</MenuItem>\r\n            </StyledMenu>\r\n\r\n            <Typography\r\n              variant=\"h6\"\r\n              component=\"div\"\r\n              sx={{ flexGrow: 1 }}\r\n            ></Typography>\r\n            <Button\r\n              variant=\"outlined\"\r\n              sx={{ ml: 2 }}\r\n              style={{ borderColor: \"lightgreen\", color: \"lightgreen\" }}\r\n              onClick={() =>\r\n                this.props.visualize(this.state.algorithm, this.state.speed)\r\n              }\r\n            >\r\n              Visualize Algorithm\r\n            </Button>\r\n\r\n            <Button\r\n              variant=\"contained\"\r\n              sx={{ ml: 2 }}\r\n              style={{ backgroundColor: \"green\" }}\r\n              onClick={() => this.props.generateMaze(this.state.maze)}\r\n            >\r\n              Generate Maze\r\n            </Button>\r\n\r\n            <Button\r\n              variant=\"contained\"\r\n              sx={{ ml: 2 }}\r\n              style={{ backgroundColor: \"darkred\" }}\r\n              onClick={() => this.props.clearGrid()}\r\n            >\r\n              Clear Grid\r\n            </Button>\r\n          </Toolbar>\r\n        </AppBar>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Navbar;\r\n","// main breadthfirstsearch function\r\nexport function breadthFirstSearch(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  const queue = [startNode];\r\n  while (!!queue.length) {\r\n    const closestNode = queue.shift();\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n    if (\r\n      !closestNode.isWall &&\r\n      (closestNode.isStart || !closestNode.isVisited)\r\n    ) {\r\n      closestNode.isVisited = true;\r\n      visitedNodesInOrder.push(closestNode);\r\n      const { col, row } = closestNode;\r\n      let nextNode;\r\n      if (row > 0) {\r\n        nextNode = grid[row - 1][col];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = closestNode;\r\n          queue.push(nextNode);\r\n        }\r\n      }\r\n      if (row < grid.length - 1) {\r\n        nextNode = grid[row + 1][col];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = closestNode;\r\n          queue.push(nextNode);\r\n        }\r\n      }\r\n      if (col > 0) {\r\n        nextNode = grid[row][col - 1];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = closestNode;\r\n          queue.push(nextNode);\r\n        }\r\n      }\r\n      if (col < grid[0].length - 1) {\r\n        nextNode = grid[row][col + 1];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = closestNode;\r\n          queue.push(nextNode);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while(currentNode !== null){\r\n      nodesInShortestPathOrder.unshift(currentNode);\r\n      currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","// main dfs function\r\nexport function dfs(grid, startNode, finishNode) {\r\n  if (!startNode || !finishNode || startNode === finishNode) {\r\n    return false;\r\n  }\r\n  const visitedNodesInOrder = [];\r\n  const stack = [];\r\n  stack.push(startNode);\r\n  while (stack.length) {\r\n    const closestNode = stack.pop();\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n    if (\r\n      !closestNode.isWall &&\r\n      (closestNode.isStart || !closestNode.isVisited)\r\n    ) {\r\n      closestNode.isVisited = true;\r\n      visitedNodesInOrder.push(closestNode);\r\n      const { col, row } = closestNode;\r\n      let nextNode;\r\n      if (row > 0) {\r\n        nextNode = grid[row - 1][col];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = closestNode;\r\n          stack.push(nextNode);\r\n        }\r\n      }\r\n      if (row < grid.length - 1) {\r\n        nextNode = grid[row + 1][col];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = closestNode;\r\n          stack.push(nextNode);\r\n        }\r\n      }\r\n      if (col > 0) {\r\n        nextNode = grid[row][col - 1];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = closestNode;\r\n          stack.push(nextNode);\r\n        }\r\n      }\r\n      if (col < grid[0].length - 1) {\r\n        nextNode = grid[row][col + 1];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = closestNode;\r\n          stack.push(nextNode);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n","export function randomMaze(grid, startNode, finishNode) {\r\n  if (!startNode || !finishNode || startNode === finishNode) {\r\n    return false;\r\n  }\r\n  let walls = [];\r\n  for (let row = 0; row < grid.length; row++) {\r\n    for (let col = 0; col < grid[0].length; col++) {\r\n      if (\r\n        (row === startNode.row && col === startNode.col) ||\r\n        (row === finishNode.row && col === finishNode.col)\r\n      )\r\n        continue;\r\n      if (Math.random() < 0.33) {\r\n        walls.push([row, col]);\r\n      }\r\n    }\r\n  }\r\n  walls.sort(() => Math.random() - 0.5);\r\n  return walls;\r\n}\r\n","import React from \"react\";\r\nimport \"./App.css\";\r\nimport PathVisualizer from \"./PathVisualizer/PathVisualizer\";\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <PathVisualizer />\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\n\r\nimport App from \"./App\";\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById(\"root\")\r\n);\r\n"],"sourceRoot":""}
{"version":3,"sources":["Path_visualizer/Node/Node.jsx","Algorithms/breadthFirstSearch.js","Algorithms/dijkastra.js","Path_visualizer/Path_visualizer.jsx","Algorithms/dfs.js","App.js","reportWebVitals.js","index.js"],"names":["Node","this","props","col","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","row","extraClassName","id","className","Component","getNodesInShortestPathOrder","finishNode","nodesInShortestPathOrder","currentNode","unshift","previousNode","dijkstra","grid","startNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","Path_visualizer","state","mouseIsPressed","getInitialGrid","setState","newGrid","getNewGridWithWallToggled","i","setTimeout","animateShortestPath","document","getElementById","animateAlgo","queue","nextNode","breadthFirstSearch","stack","pop","dfs","onClick","visualizeDijkstra","visualizeBfs","visualizedfs","map","rowIdx","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","currentRow","createNode","slice","newNode","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.9880da5b.chunk.js","sourcesContent":["import React, { Component } from 'react';\r\n\r\nimport './Node.css';\r\n\r\nexport default class Node extends Component {\r\n\r\n    render() {\r\n        const { \r\n            col, \r\n            isFinish, \r\n            isStart,\r\n            isWall,\r\n            onMouseDown,\r\n            onMouseEnter,\r\n            onMouseUp,\r\n            row,\r\n    } = this.props;\r\n        const extraClassName = isFinish\r\n            ? 'node-finish'\r\n            : isStart\r\n            ? 'node-start'\r\n            : isWall\r\n            ? 'node-wall'\r\n            : '';\r\n\r\n        return (\r\n            <div \r\n                id={`node-${row}-${col}`}\r\n                className={`node ${extraClassName}`}\r\n                onMouseDown={() => onMouseDown(row, col)}\r\n                onMouseEnter={() => onMouseEnter(row, col)}\r\n                onMouseUp={() => onMouseUp(row, col)}\r\n            ></div>\r\n        );\r\n    }\r\n}\r\n","// main breadthfirstsearch function\r\nexport function breadthFirstSearch(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  const queue = [startNode];\r\n  while (!!queue.length) {\r\n    const closestNode = queue.shift();\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n    if (\r\n      !closestNode.isWall &&\r\n      (closestNode.isStart || !closestNode.isVisited)\r\n    ) {\r\n      closestNode.isVisited = true;\r\n      visitedNodesInOrder.push(closestNode);\r\n      const { col, row } = closestNode;\r\n      let nextNode;\r\n      if (row > 0) {\r\n        nextNode = grid[row - 1][col];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = closestNode;\r\n          queue.push(nextNode);\r\n        }\r\n      }\r\n      if (row < grid.length - 1) {\r\n        nextNode = grid[row + 1][col];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = closestNode;\r\n          queue.push(nextNode);\r\n        }\r\n      }\r\n      if (col > 0) {\r\n        nextNode = grid[row][col - 1];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = closestNode;\r\n          queue.push(nextNode);\r\n        }\r\n      }\r\n      if (col < grid[0].length - 1) {\r\n        nextNode = grid[row][col + 1];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = closestNode;\r\n          queue.push(nextNode);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while(currentNode !== null){\r\n      nodesInShortestPathOrder.unshift(currentNode);\r\n      currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","// main dijkstra's function \r\nexport function dijkstra(grid, startNode, finishNode){\r\n    const visitedNodesInOrder = [];\r\n    startNode.distance = 0;\r\n    const unvisitedNodes = getAllNodes(grid);\r\n    while(!!unvisitedNodes.length){\r\n        sortNodesByDistance(unvisitedNodes);\r\n        const closestNode = unvisitedNodes.shift();\r\n        if(closestNode.isWall) continue;\r\n        if(closestNode.distance === Infinity) return visitedNodesInOrder;\r\n        closestNode.isVisited = true;\r\n        visitedNodesInOrder.push(closestNode);\r\n        if(closestNode === finishNode) return visitedNodesInOrder;\r\n        updateUnvisitedNeighbors(closestNode, grid);\r\n    }\r\n}\r\n// get all nodes of grid\r\nfunction getAllNodes(grid){\r\n    const nodes = [];\r\n    for(const row of grid){\r\n        for(const node of row){\r\n            nodes.push(node);\r\n        }\r\n    }\r\n    return nodes;\r\n}\r\n// sort the nodes by distance\r\nfunction sortNodesByDistance(unvisitedNodes){\r\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n// update unvisited neighbors\r\nfunction updateUnvisitedNeighbors(node, grid){\r\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n    for(const neighbor of unvisitedNeighbors){\r\n        neighbor.distance = node.distance + 1;\r\n        neighbor.previousNode = node;\r\n    }\r\n}\r\n// Find unvisited neighbor node\r\nfunction getUnvisitedNeighbors(node, grid){\r\n    const neighbors = [];\r\n    const {col, row} = node;\r\n    if(row > 0) neighbors.push(grid[row - 1][col]);\r\n    if(row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n    if(col > 0) neighbors.push(grid[row][col - 1]);\r\n    if(col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n    return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}\r\n\r\n// Find Shortest Path After the Dijkstra Function run using backtracking \r\nexport function getNodesInShortestPathOrder(finishNode){\r\n    const nodesInShortestPathOrder = [];\r\n    let currentNode = finishNode;\r\n    while(currentNode !== null){\r\n        nodesInShortestPathOrder.unshift(currentNode);\r\n        currentNode = currentNode.previousNode;\r\n    }\r\n    return nodesInShortestPathOrder;\r\n}\r\n","import React, { Component } from 'react';\r\nimport Node from './Node/Node';\r\nimport {breadthFirstSearch, getNodesInShortestPathOrder} from '../Algorithms/breadthFirstSearch';\r\nimport {dijkstra} from '../Algorithms/dijkastra';\r\nimport {dfs} from '../Algorithms/dfs';\r\n// import {greedybfs} from '../Algorithms/gbfs';\r\nimport './Path_visualizer.css';\r\n\r\nconst START_NODE_ROW = 10;\r\nconst START_NODE_COL = 15;\r\nconst FINISH_NODE_ROW = 10;\r\nconst FINISH_NODE_COL = 35;\r\n\r\nexport default class Path_visualizer extends Component {\r\n    constructor() {\r\n        super();\r\n        this.state = {\r\n            grid: [],\r\n            mouseIsPressed: false,\r\n        };\r\n    }\r\n    componentDidMount() {\r\n        const grid = getInitialGrid();\r\n        this.setState({ grid });\r\n    }\r\n\r\n    handleMouseDown(row, col){\r\n        const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n        this.setState({grid: newGrid, mouseIsPressed: true});\r\n        // console.log(\"Mouse Down\");\r\n    }\r\n\r\n    handleMouseEnter(row, col){\r\n        if(!this.state.mouseIsPressed) return;\r\n        const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n        this.setState({grid: newGrid});\r\n        // console.log(\"Mouse Enter\");\r\n    }\r\n\r\n    handleMouseUp(){\r\n        this.setState({mouseIsPressed: false});\r\n        // console.log(\"Mouse Up\");\r\n    }\r\n\r\n    animateAlgo(visitedNodesInOrder, nodesInShortestPathOrder){\r\n        for(let i = 0; i <= visitedNodesInOrder.length; i++){\r\n            if(i === visitedNodesInOrder.length){\r\n                setTimeout(() => {\r\n                    this.animateShortestPath(nodesInShortestPathOrder);    \r\n                }, 25 * i);\r\n                return;\r\n            }\r\n            setTimeout(() => {\r\n                const node = visitedNodesInOrder[i];\r\n                document.getElementById(`node-${node.row}-${node.col}`).className = \r\n                    'node node-visited';\r\n            }, 25 * i);\r\n        }\r\n    }\r\n\r\n        animateShortestPath(nodesInShortestPathOrder){\r\n            for(let i = 0; i < nodesInShortestPathOrder.length; i++){\r\n                setTimeout(() => {\r\n                    const node = nodesInShortestPathOrder[i];\r\n                    document.getElementById(`node-${node.row}-${node.col}`).className = \r\n                        'node node-shortest-path';\r\n                }, 25 * i);\r\n            }\r\n        }\r\n\r\n        visualizeDijkstra(){\r\n            const {grid} = this.state;\r\n            const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n            const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n            const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\r\n            const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n            this.animateAlgo(visitedNodesInOrder, nodesInShortestPathOrder);\r\n        }\r\n        visualizeBfs(){\r\n            const {grid} = this.state;\r\n            const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n            const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n            const visitedNodesInOrder = breadthFirstSearch(grid, startNode, finishNode);\r\n            const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n            this.animateAlgo(visitedNodesInOrder, nodesInShortestPathOrder);\r\n        }\r\n        visualizedfs(){\r\n            const {grid} = this.state;\r\n            const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n            const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n            const visitedNodesInOrder = dfs(grid, startNode, finishNode);\r\n            const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n            this.animateAlgo(visitedNodesInOrder, nodesInShortestPathOrder);\r\n        }\r\n\r\n    render() {\r\n        const { grid, mouseIsPressed } = this.state;\r\n\r\n        return (\r\n            <>\r\n                <button onClick={() => this.visualizeDijkstra()}>\r\n                    Dijkstra\r\n                </button>\r\n                <button onClick={() => this.visualizeBfs()}>\r\n                    Breadth First Search\r\n                </button>\r\n                <button onClick={() => this.visualizedfs()}>\r\n                    Depth First Search\r\n                </button>\r\n                <div className=\"grid\">\r\n                    {grid.map((row, rowIdx) => {\r\n                        return (\r\n                            <div key={rowIdx} className=\"rowid\">\r\n                                {row.map((node, nodeIdx) => {\r\n                                    const { row, col, isFinish, isStart, isWall } = node;\r\n                                    return (\r\n                                        <Node\r\n                                            key={nodeIdx}\r\n                                            col={col}\r\n                                            isFinish={isFinish}\r\n                                            isStart={isStart}\r\n                                            row={row}\r\n                                            isWall={isWall}\r\n                                            mouseIsPressed={mouseIsPressed}\r\n                                            onMouseDown={(row, col) => this.handleMouseDown(row, col)}\r\n                                            onMouseEnter={(row, col) => this.handleMouseEnter(row, col)}\r\n                                            onMouseUp={() => this.handleMouseUp()}>\r\n                                        </Node>\r\n                                    );\r\n                                })}\r\n                            </div>\r\n                        );\r\n                    })}\r\n                </div>\r\n            </>\r\n        );\r\n    }\r\n}\r\n\r\nconst getInitialGrid = () => {\r\n    const grid = [];\r\n    for (let row = 0; row < 20; row++) {\r\n        const currentRow = [];\r\n        for (let col = 0; col < 50; col++) {\r\n            currentRow.push(createNode(col, row));\r\n        }\r\n        grid.push(currentRow);\r\n    }\r\n    return grid;\r\n};\r\n\r\nconst createNode = (col, row) => {\r\n    return {\r\n        col,\r\n        row,\r\n        isStart: row === START_NODE_ROW && col === START_NODE_COL,\r\n        isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\r\n        distance: Infinity,\r\n        previousNode: null,\r\n    };\r\n};\r\n\r\nconst getNewGridWithWallToggled = (grid, row, col) => {\r\n    const newGrid = grid.slice();\r\n    const node = newGrid[row][col];\r\n    const newNode = {\r\n        ...node,\r\n        isWall: !node.isWall,\r\n    };\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n}","// main dfs function\r\nexport function dfs(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  const stack = [];\r\n  stack.push(startNode);\r\n  while (stack.length) {\r\n    const closestNode = stack.pop();\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n    if (\r\n      !closestNode.isWall &&\r\n      (closestNode.isStart || !closestNode.isVisited)\r\n    ) {\r\n      closestNode.isVisited = true;\r\n      visitedNodesInOrder.push(closestNode);\r\n      const {col, row} = closestNode;\r\n      let nextNode;\r\n      if(row > 0){\r\n        nextNode = grid[row - 1][col];\r\n        if(!nextNode.isVisited){\r\n          nextNode.previousNode = closestNode;\r\n          stack.push(nextNode);\r\n        }\r\n      }\r\n      if(row < grid.length - 1){\r\n        nextNode = grid[row + 1][col];\r\n        if(!nextNode.isVisited){\r\n          nextNode.previousNode = closestNode;\r\n          stack.push(nextNode);\r\n        }\r\n      }\r\n      if(col > 0){\r\n        nextNode = grid[row][col - 1];\r\n        if(!nextNode.isVisited){\r\n          nextNode.previousNode = closestNode;\r\n          stack.push(nextNode);\r\n        }\r\n      }\r\n      if(col < grid[0].length - 1){\r\n        nextNode = grid[row][col + 1];\r\n        if(!nextNode.isVisited){\r\n          nextNode.previousNode = closestNode;\r\n          stack.push(nextNode);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n","import React from 'react';\r\nimport './App.css';\r\nimport Path_visualizer from './Path_visualizer/Path_visualizer';\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <Path_visualizer></Path_visualizer>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","const reportWebVitals = onPerfEntry => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n      getCLS(onPerfEntry);\r\n      getFID(onPerfEntry);\r\n      getFCP(onPerfEntry);\r\n      getLCP(onPerfEntry);\r\n      getTTFB(onPerfEntry);\r\n    });\r\n  }\r\n};\r\n\r\nexport default reportWebVitals;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport reportWebVitals from './reportWebVitals';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}
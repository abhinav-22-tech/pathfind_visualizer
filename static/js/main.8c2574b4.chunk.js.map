{"version":3,"sources":["Path_visualizer/Node/Node.jsx","Algorithms/breadthFirstSearch.js","Algorithms/dijkstra.js","Algorithms/dfs.js","Algorithms/astar.js","Algorithms/greedyBestFirstSearch.js","Algorithms/randomWalk.js","Path_visualizer/ui.js","Path_visualizer/Path_visualizer.jsx","App.js","reportWebVitals.js","index.js"],"names":["Node","this","props","col","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","row","extraClassName","id","className","Component","breadthFirstSearch","grid","startNode","finishNode","visitedNodesInOrder","queue","length","closestNode","shift","isVisited","push","nextNode","previousNode","dijkstra","distance","unvisitedNodes","nodes","node","getAllNodes","sortNodesByDistance","Infinity","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","dfs","stack","pop","astar","a","b","totalDistance","neighbours","getNeighbours","neighbour","neighbourNotInUnvisitedNodes","unshift","heuristic","Math","abs","greedyBFS","randomWalk","maxNodes","maxNodesVisitedTracker","loopTracker","randomNeighbour","getRandomNeighbour","nodesVisited","numNodesVisited","neighboursFilteredStartAndWall","neighboursFilteredVisited","floor","random","count","useStyles","makeStyles","theme","root","flexGrow","title","subTitle","ButtonAppBar","classes","AppBar","position","style","background","Toolbar","Typography","variant","Button","padding","backgroundColor","color","fontSize","Path_visualizer","animateRandomWalk","i","setTimeout","setState","visualizingAlgorithm","state","speed","document","getElementById","mouseIsPressed","getInitialGrid","newGrid","getNewGridWithWallToggled","nodesInShortestPathOrder","animateShortestPath","algo","currentNode","getNodesInShortestPathOrder","animateAlgo","onClick","visualize","map","rowIdx","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","currentRow","createNode","slice","newNode","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.8c2574b4.chunk.js","sourcesContent":["import React, { Component } from 'react';\r\n\r\nimport './Node.css';\r\n\r\nexport default class Node extends Component {\r\n\r\n    render() {\r\n        const { \r\n            col, \r\n            isFinish, \r\n            isStart,\r\n            isWall,\r\n            onMouseDown,\r\n            onMouseEnter,\r\n            onMouseUp,\r\n            row,\r\n    } = this.props;\r\n        const extraClassName = isFinish\r\n            ? 'node-finish'\r\n            : isStart\r\n            ? 'node-start'\r\n            : isWall\r\n            ? 'node-wall'\r\n            : '';\r\n\r\n        return (\r\n            <div \r\n                id={`node-${row}-${col}`}\r\n                className={`node ${extraClassName}`}\r\n                onMouseDown={() => onMouseDown(row, col)}\r\n                onMouseEnter={() => onMouseEnter(row, col)}\r\n                onMouseUp={() => onMouseUp(row, col)}\r\n            ></div>\r\n        );\r\n    }\r\n}\r\n","// main breadthfirstsearch function\r\nexport function breadthFirstSearch(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  const queue = [startNode];\r\n  while (!!queue.length) {\r\n    const closestNode = queue.shift();\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n    if (\r\n      !closestNode.isWall &&\r\n      (closestNode.isStart || !closestNode.isVisited)\r\n    ) {\r\n      closestNode.isVisited = true;\r\n      visitedNodesInOrder.push(closestNode);\r\n      const { col, row } = closestNode;\r\n      let nextNode;\r\n      if (row > 0) {\r\n        nextNode = grid[row - 1][col];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = closestNode;\r\n          queue.push(nextNode);\r\n        }\r\n      }\r\n      if (row < grid.length - 1) {\r\n        nextNode = grid[row + 1][col];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = closestNode;\r\n          queue.push(nextNode);\r\n        }\r\n      }\r\n      if (col > 0) {\r\n        nextNode = grid[row][col - 1];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = closestNode;\r\n          queue.push(nextNode);\r\n        }\r\n      }\r\n      if (col < grid[0].length - 1) {\r\n        nextNode = grid[row][col + 1];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = closestNode;\r\n          queue.push(nextNode);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while(currentNode !== null){\r\n      nodesInShortestPathOrder.unshift(currentNode);\r\n      currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","// main dijkstra's function \r\nexport function dijkstra(grid, startNode, finishNode){\r\n    const visitedNodesInOrder = [];\r\n    startNode.distance = 0;\r\n    const unvisitedNodes = getAllNodes(grid);\r\n    while(!!unvisitedNodes.length){\r\n        sortNodesByDistance(unvisitedNodes);\r\n        const closestNode = unvisitedNodes.shift();\r\n        if(closestNode.isWall) continue;\r\n        if(closestNode.distance === Infinity) return visitedNodesInOrder;\r\n        closestNode.isVisited = true;\r\n        visitedNodesInOrder.push(closestNode);\r\n        if(closestNode === finishNode) return visitedNodesInOrder;\r\n        updateUnvisitedNeighbors(closestNode, grid);\r\n    }\r\n}\r\n// get all nodes of grid\r\nfunction getAllNodes(grid){\r\n    const nodes = [];\r\n    for(const row of grid){\r\n        for(const node of row){\r\n            nodes.push(node);\r\n        }\r\n    }\r\n    return nodes;\r\n}\r\n// sort the nodes by distance\r\nfunction sortNodesByDistance(unvisitedNodes){\r\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n// update unvisited neighbors\r\nfunction updateUnvisitedNeighbors(node, grid){\r\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n    for(const neighbor of unvisitedNeighbors){\r\n        neighbor.distance = node.distance + 1;\r\n        neighbor.previousNode = node;\r\n    }\r\n}\r\n// Find unvisited neighbor node\r\nfunction getUnvisitedNeighbors(node, grid){\r\n    const neighbors = [];\r\n    const {col, row} = node;\r\n    if(row > 0) neighbors.push(grid[row - 1][col]);\r\n    if(row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n    if(col > 0) neighbors.push(grid[row][col - 1]);\r\n    if(col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n    return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}\r\n\r\n// Find Shortest Path After the Dijkstra Function run using backtracking \r\nexport function getNodesInShortestPathOrder(finishNode){\r\n    const nodesInShortestPathOrder = [];\r\n    let currentNode = finishNode;\r\n    while(currentNode !== null){\r\n        nodesInShortestPathOrder.unshift(currentNode);\r\n        currentNode = currentNode.previousNode;\r\n    }\r\n    return nodesInShortestPathOrder;\r\n}\r\n","// main dfs function\r\nexport function dfs(grid, startNode, finishNode) {\r\n  if (!startNode || !finishNode || startNode === finishNode) {\r\n    return false;\r\n  }\r\n  const visitedNodesInOrder = [];\r\n  const stack = [];\r\n  stack.push(startNode);\r\n  while (stack.length) {\r\n    const closestNode = stack.pop();\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n    if (\r\n      !closestNode.isWall &&\r\n      (closestNode.isStart || !closestNode.isVisited)\r\n    ) {\r\n      closestNode.isVisited = true;\r\n      visitedNodesInOrder.push(closestNode);\r\n      const { col, row } = closestNode;\r\n      let nextNode;\r\n      if (row > 0) {\r\n        nextNode = grid[row - 1][col];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = closestNode;\r\n          stack.push(nextNode);\r\n        }\r\n      }\r\n      if (row < grid.length - 1) {\r\n        nextNode = grid[row + 1][col];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = closestNode;\r\n          stack.push(nextNode);\r\n        }\r\n      }\r\n      if (col > 0) {\r\n        nextNode = grid[row][col - 1];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = closestNode;\r\n          stack.push(nextNode);\r\n        }\r\n      }\r\n      if (col < grid[0].length - 1) {\r\n        nextNode = grid[row][col + 1];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = closestNode;\r\n          stack.push(nextNode);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n","export function astar(grid, startNode, finishNode) {\r\n  if (!startNode || !finishNode || startNode === finishNode) {\r\n    return false;\r\n  }\r\n  let unvisitedNodes = []; //open list\r\n  let visitedNodesInOrder = []; //closed list\r\n  startNode.distance = 0;\r\n  unvisitedNodes.push(startNode);\r\n\r\n  while (unvisitedNodes.length !== 0) {\r\n    unvisitedNodes.sort((a, b) => a.totalDistance - b.totalDistance);\r\n    let closestNode = unvisitedNodes.shift();\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n\r\n    let neighbours = getNeighbours(closestNode, grid);\r\n    for (let neighbour of neighbours) {\r\n      let distance = closestNode.distance + 1;\r\n      //f(n) = g(n) + h(n)\r\n      if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes)) {\r\n        unvisitedNodes.unshift(neighbour);\r\n        neighbour.distance = distance;\r\n        neighbour.totalDistance =\r\n          distance + heuristic(neighbour, finishNode);\r\n        neighbour.previousNode = closestNode;\r\n      } else if (distance < neighbour.distance) {\r\n        neighbour.distance = distance;\r\n        neighbour.totalDistance =\r\n          distance + heuristic(neighbour, finishNode);\r\n        neighbour.previousNode = closestNode;\r\n      }\r\n    }\r\n  }\r\n  return visitedNodesInOrder;\r\n}\r\n\r\nfunction getNeighbours(node, grid) {\r\n  let neighbours = [];\r\n  let { row, col } = node;\r\n  if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\r\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\r\n  if (col !== 0) neighbours.push(grid[row][col - 1]);\r\n  if (row !== 0) neighbours.push(grid[row - 1][col]);\r\n  return neighbours.filter(\r\n    (neighbour) => !neighbour.isWall && !neighbour.isVisited\r\n  );\r\n}\r\n\r\nfunction neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\r\n  for (let node of unvisitedNodes) {\r\n    if (node.row === neighbour.row && node.col === neighbour.col) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nfunction heuristic(node, finishNode) {\r\n  let x = Math.abs(node.row - finishNode.row);\r\n  let y = Math.abs(node.col - finishNode.col);\r\n  return x + y;\r\n}\r\n\r\n\r\n","export function greedyBFS(grid, startNode, finishNode) {\r\n  if (!startNode || !finishNode || startNode === finishNode) {\r\n    return false;\r\n  }\r\n  let unvisitedNodes = []; //open list\r\n  let visitedNodesInOrder = []; //closed list\r\n  startNode.distance = 0;\r\n  unvisitedNodes.push(startNode);\r\n\r\n  while (unvisitedNodes.length !== 0) {\r\n    unvisitedNodes.sort((a, b) => a.totalDistance - b.totalDistance);\r\n    let closestNode = unvisitedNodes.shift();\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n\r\n    let neighbours = getNeighbours(closestNode, grid);\r\n    for (let neighbour of neighbours) {\r\n      let distance = closestNode.distance + 1;\r\n      //f(n) = h(n)\r\n      if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes)) {\r\n        unvisitedNodes.unshift(neighbour);\r\n        neighbour.distance = distance;\r\n        neighbour.totalDistance = heuristic(neighbour, finishNode);\r\n        neighbour.previousNode = closestNode;\r\n      } else if (distance < neighbour.distance) {\r\n        neighbour.distance = distance;\r\n        neighbour.totalDistance = heuristic(neighbour, finishNode);\r\n        neighbour.previousNode = closestNode;\r\n      }\r\n    }\r\n  }\r\n  return visitedNodesInOrder;\r\n}\r\n\r\nfunction getNeighbours(node, grid) {\r\n  let neighbours = [];\r\n  let { row, col } = node;\r\n  if (row !== 0) neighbours.push(grid[row - 1][col]);\r\n  if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\r\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\r\n  if (col !== 0) neighbours.push(grid[row][col - 1]);\r\n  return neighbours.filter(\r\n    (neighbour) => !neighbour.isWall && !neighbour.isVisited\r\n  );\r\n}\r\n\r\nfunction heuristic(node, finishNode) {\r\n  let x = Math.abs(node.row - finishNode.row);\r\n  let y = Math.abs(node.col - finishNode.col);\r\n  return x + y;\r\n}\r\n\r\nfunction neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\r\n  for (let node of unvisitedNodes) {\r\n    if (node.row === neighbour.row && node.col === neighbour.col) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\n","export function randomWalk(grid, startNode, finishNode) {\r\n  // if (!startNode || !finishNode || startNode === finishNode) {\r\n  //   return false;\r\n  // }\r\n  let visitedNodesInOrder = [];\r\n  let closestNode = startNode;\r\n  let maxNodes = grid.length * grid[0].length;\r\n  let maxNodesVisitedTracker = 0;\r\n  let loopTracker = 0;\r\n  while (true) {\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n    let randomNeighbour = getRandomNeighbour(closestNode, grid, finishNode);\r\n    let nodesVisited = numNodesVisited(grid);\r\n    if (nodesVisited === maxNodes - 2) {\r\n      return visitedNodesInOrder;\r\n    }\r\n    if (nodesVisited > maxNodesVisitedTracker) {\r\n      maxNodesVisitedTracker = nodesVisited;\r\n      loopTracker = 0;\r\n    } else if ((nodesVisited = maxNodesVisitedTracker)) {\r\n      loopTracker += 1;\r\n      if (loopTracker > 1000) {\r\n        return visitedNodesInOrder;\r\n      }\r\n    }\r\n    randomNeighbour.previousNode = closestNode;\r\n    closestNode = randomNeighbour;\r\n  }\r\n}\r\n\r\nfunction getRandomNeighbour(node, grid, finishNode) {\r\n  let neighbours = [];\r\n  let { row, col } = node;\r\n  if (row !== 0) neighbours.push(grid[row - 1][col]);\r\n  if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\r\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\r\n  if (col !== 0) neighbours.push(grid[row][col - 1]);\r\n  let neighboursFilteredStartAndWall = neighbours.filter(\r\n    (neighbour) => !neighbour.isStart && !neighbour.isWall\r\n  );\r\n  let neighboursFilteredVisited = neighboursFilteredStartAndWall.filter(\r\n    (neighbour) => !neighbour.isVisited\r\n  );\r\n  if (neighboursFilteredVisited.length > 0) {\r\n    return neighboursFilteredVisited[\r\n      Math.floor(Math.random() * neighboursFilteredVisited.length)\r\n    ];\r\n  }\r\n  return neighboursFilteredStartAndWall[\r\n    Math.floor(Math.random() * neighboursFilteredStartAndWall.length)\r\n  ];\r\n}\r\n\r\nfunction numNodesVisited(grid) {\r\n  let count = 0;\r\n  for (let row of grid) {\r\n    for (let node of row) {\r\n      if (node.isVisited || node.isWall) count += 1;\r\n    }\r\n  }\r\n  return count;\r\n}\r\n","import React from \"react\";\r\nimport {\r\n  makeStyles,\r\n  AppBar,\r\n  Toolbar,\r\n  Typography,\r\n  Button,\r\n} from \"@material-ui/core\";\r\n\r\nconst useStyles = makeStyles((theme) => ({\r\n  root: {\r\n    flexGrow: 1,\r\n  },\r\n  title: {\r\n    flexGrow: 3,\r\n  },\r\n  subTitle: {\r\n    flexGrow: 1,\r\n  },\r\n}));\r\n\r\nexport default function ButtonAppBar() {\r\n  const classes = useStyles();\r\n\r\n  return (\r\n    <div className={classes.root}>\r\n      <AppBar position=\"static\" style={{ background: \"#391763\" }}>\r\n        <Toolbar>\r\n          <Typography variant=\"h5\" className={classes.title}>\r\n            Path Finding\r\n          </Typography>\r\n\r\n          <Button\r\n            variant=\"variant\"\r\n            style={{\r\n              padding: \"13px 16px\",\r\n              backgroundColor: \"#069983\",\r\n              color: \"#FFFFFF\",\r\n              fontSize: \"15px\",\r\n            }}\r\n            className={classes.subTitle}\r\n          >\r\n            Visualize!\r\n          </Button>\r\n\r\n          <Button\r\n            variant=\"variant\"\r\n            style={{ color: \"#FFFFFF\" }}\r\n            className={classes.subTitle}\r\n          >\r\n            Algorithm\r\n          </Button>\r\n\r\n          <Button\r\n            variant=\"variant\"\r\n            style={{ color: \"#FFFFFF\" }}\r\n            className={classes.subTitle}\r\n          >\r\n            Mazes & Pattern\r\n          </Button>\r\n\r\n          <Button\r\n            variant=\"variant\"\r\n            style={{ color: \"#FFFFFF\" }}\r\n            className={classes.subTitle}\r\n          >\r\n            Speed\r\n          </Button>\r\n\r\n          <Typography variant=\"h6\" className={classes.subTitle}>\r\n            Time Taken: 10ms\r\n          </Typography>\r\n        </Toolbar>\r\n      </AppBar>\r\n    </div>\r\n  );\r\n}\r\n","import React, { Component } from \"react\";\r\nimport Node from \"./Node/Node\";\r\nimport {\r\n  breadthFirstSearch,\r\n  getNodesInShortestPathOrder,\r\n} from \"../Algorithms/breadthFirstSearch\";\r\nimport { dijkstra } from \"../Algorithms/dijkstra\";\r\nimport { dfs } from \"../Algorithms/dfs\";\r\nimport { astar } from \"../Algorithms/astar\";\r\nimport { greedyBFS } from \"../Algorithms/greedyBestFirstSearch\";\r\nimport { randomWalk } from \"../Algorithms/randomWalk\";\r\nimport \"./Path_visualizer.css\";\r\n\r\nimport UI from \"./ui\";\r\n\r\nconst START_NODE_ROW = 10;\r\nconst START_NODE_COL = 15;\r\nconst FINISH_NODE_ROW = 10;\r\nconst FINISH_NODE_COL = 35;\r\n\r\nexport default class Path_visualizer extends Component {\r\n  constructor() {\r\n    super();\r\n    this.state = {\r\n      grid: [],\r\n      mouseIsPressed: false,\r\n    };\r\n  }\r\n  componentDidMount() {\r\n    const grid = getInitialGrid();\r\n    this.setState({ grid });\r\n  }\r\n\r\n  handleMouseDown(row, col) {\r\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n    this.setState({ grid: newGrid, mouseIsPressed: true });\r\n    // console.log(\"Mouse Down\");\r\n  }\r\n\r\n  handleMouseEnter(row, col) {\r\n    if (!this.state.mouseIsPressed) return;\r\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n    this.setState({ grid: newGrid });\r\n    // console.log(\"Mouse Enter\");\r\n  }\r\n\r\n  handleMouseUp() {\r\n    this.setState({ mouseIsPressed: false });\r\n    // console.log(\"Mouse Up\");\r\n  }\r\n\r\n  animateAlgo(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n      if (i === visitedNodesInOrder.length) {\r\n        setTimeout(() => {\r\n          this.animateShortestPath(nodesInShortestPathOrder);\r\n        }, 25 * i);\r\n        return;\r\n      }\r\n      setTimeout(() => {\r\n        const node = visitedNodesInOrder[i];\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node-visited\";\r\n      }, 25 * i);\r\n    }\r\n  }\r\n\r\n  animateShortestPath(nodesInShortestPathOrder) {\r\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n      setTimeout(() => {\r\n        const node = nodesInShortestPathOrder[i];\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node-shortest-path\";\r\n      }, 25 * i);\r\n    }\r\n  }\r\n\r\n  animateRandomWalk = (visitedNodesInOrder) => {\r\n    for (let i = 1; i <= visitedNodesInOrder.length; i++) {\r\n      if (i === visitedNodesInOrder.length) {\r\n        setTimeout(() => {\r\n          this.setState({ visualizingAlgorithm: false });\r\n        }, i * this.state.speed);\r\n        return;\r\n      }\r\n      let node = visitedNodesInOrder[i];\r\n      if (i === visitedNodesInOrder.length - 1) {\r\n        setTimeout(() => {\r\n          //finish node\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node-finish-reached\";\r\n        }, i * this.state.speed);\r\n        continue;\r\n      }\r\n      setTimeout(() => {\r\n        //visited node\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node-visited\";\r\n      }, i * 25);\r\n    }\r\n  };\r\n\r\n  visualize(algo) {\r\n    const { grid } = this.state;\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    let visitedNodesInOrder = \"\";\r\n\r\n    if (algo === dijkstra)\r\n      visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\r\n    else if (algo === breadthFirstSearch)\r\n      visitedNodesInOrder = breadthFirstSearch(grid, startNode, finishNode);\r\n    else if (algo === dfs)\r\n      visitedNodesInOrder = dfs(grid, startNode, finishNode);\r\n    else if (algo === astar)\r\n      visitedNodesInOrder = astar(grid, startNode, finishNode);\r\n    else if (algo === greedyBFS)\r\n      visitedNodesInOrder = greedyBFS(grid, startNode, finishNode);\r\n    else if (algo === randomWalk)\r\n      visitedNodesInOrder = randomWalk(grid, startNode, finishNode);\r\n\r\n    if (algo === randomWalk) {\r\n      this.animateRandomWalk(visitedNodesInOrder);\r\n    } else {\r\n      const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n      this.animateAlgo(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    }\r\n  }\r\n\r\n  render() {\r\n    const { grid, mouseIsPressed } = this.state;\r\n\r\n    return (\r\n      <>\r\n        <UI />\r\n        <button onClick={() => this.visualize(dijkstra)}>Dijkstra</button>\r\n        <button onClick={() => this.visualize(breadthFirstSearch)}>\r\n          Breadth First Search\r\n        </button>\r\n        <button onClick={() => this.visualize(dfs)}>Depth First Search</button>\r\n        <button onClick={() => this.visualize(astar)}>A *</button>\r\n        <button onClick={() => this.visualize(greedyBFS)}>\r\n          Greedy Best First Search\r\n        </button>\r\n        <button onClick={() => this.visualize(randomWalk)}>Random Walk</button>\r\n        <div className=\"grid\">\r\n          {grid.map((row, rowIdx) => {\r\n            return (\r\n              <div key={rowIdx} className=\"rowid\">\r\n                {row.map((node, nodeIdx) => {\r\n                  const { row, col, isFinish, isStart, isWall } = node;\r\n                  return (\r\n                    <Node\r\n                      key={nodeIdx}\r\n                      col={col}\r\n                      isFinish={isFinish}\r\n                      isStart={isStart}\r\n                      row={row}\r\n                      isWall={isWall}\r\n                      mouseIsPressed={mouseIsPressed}\r\n                      onMouseDown={(row, col) => this.handleMouseDown(row, col)}\r\n                      onMouseEnter={(row, col) =>\r\n                        this.handleMouseEnter(row, col)\r\n                      }\r\n                      onMouseUp={() => this.handleMouseUp()}\r\n                    ></Node>\r\n                  );\r\n                })}\r\n              </div>\r\n            );\r\n          })}\r\n        </div>\r\n      </>\r\n    );\r\n  }\r\n}\r\n\r\nconst getInitialGrid = () => {\r\n  const grid = [];\r\n  for (let row = 0; row < 22; row++) {\r\n    const currentRow = [];\r\n    for (let col = 0; col < 60; col++) {\r\n      currentRow.push(createNode(col, row));\r\n    }\r\n    grid.push(currentRow);\r\n  }\r\n  return grid;\r\n};\r\n\r\nconst createNode = (col, row) => {\r\n  return {\r\n    col,\r\n    row,\r\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\r\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\r\n    distance: Infinity,\r\n    previousNode: null,\r\n  };\r\n};\r\n\r\nconst getNewGridWithWallToggled = (grid, row, col) => {\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n  const newNode = {\r\n    ...node,\r\n    isWall: !node.isWall,\r\n  };\r\n  newGrid[row][col] = newNode;\r\n  return newGrid;\r\n};\r\n","import React from 'react';\r\nimport './App.css';\r\nimport Path_visualizer from './Path_visualizer/Path_visualizer';\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <Path_visualizer/>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","const reportWebVitals = onPerfEntry => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n      getCLS(onPerfEntry);\r\n      getFID(onPerfEntry);\r\n      getFCP(onPerfEntry);\r\n      getLCP(onPerfEntry);\r\n      getTTFB(onPerfEntry);\r\n    });\r\n  }\r\n};\r\n\r\nexport default reportWebVitals;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport reportWebVitals from './reportWebVitals';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}